#include "imports/stdlib.fc";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {

}

;; æ–¹æ³•å¯ä»¥ä¸»åŠ¨è¿”å›ž return ();
() send_money(slice address, int amount) impure inline {
    ;; ä¸‹é¢ä»£ç æ˜¯æž„é€ äº†ä¸€ä¸ªæ¶ˆæ¯ï¼Œæ¶ˆæ¯åŒ…å«ç›®æ ‡åœ°å€addressï¼Œ
    ;; ç„¶åŽè°ƒç”¨ send_raw_message å°†æ¶ˆæ¯å‘é€åˆ° TON ç½‘ç»œè¿›è¡ŒæŠ•é€’
    ;; å…¶ä¸­çš„ store_coins ä»£è¡¨æ¶ˆæ¯é™„å¸¦å¤šå°‘ Toncoin å‡ºåŽ»
    ;; å…¶ä¸­çš„ 64 ä»£è¡¨ ç»…å£«æ¨¡å¼ï¼Œå°† inbound message çš„å‰©ä½™ä»·å€¼å¸¦èµ°ï¼Œå¹¶ä¸”åŒ…å«â€œå°è´¹â€amountï¼Œä¹Ÿä¼šä¸€å¹¶å¸¦èµ°
    ;; å› ä¸ºæ²¡æœ‰è®¾ç½® 64+1 , æ‰€ä»¥ä»Žæ¶ˆæ¯ä¸­æ‰£é™¤å‘é€çš„ gas
    ;; å¦‚æžœè®¾ç½®äº† 64+1 , ä»£è¡¨ä»Žå‘é€åˆçº¦çš„ä½™é¢æ¥æ‰£é™¤å‘é€æ¶ˆæ¯éœ€è¦çš„ gas

    var msg = begin_cell()
        .store_uint(0x10,6);; è¡¨ç¤º nobounce ;; 0x10 æ˜¯ åå…­è¿›åˆ¶ï¼Œè½¬ä¸º 10è¿›åˆ¶æ˜¯ 16. é•¿åº¦ 6
        .store_slice(address) ;; slice æ ¼å¼çš„ address
        .store_coins(amount)
        .end_cell();

    send_raw_message(msg, 64);
}

() basic_syntax() {
    int flag = 0; ;;0 is false
    if(flag){
    }else{
    }

    int number = 2;
    int multiplier = number;
    int degree = 5;
    repeat(degree - 1){
        number *= multiplier;
    }
}


() while_loop_refs() {
    cell inner_cell = begin_cell()
        .store_uint(123,16).end_cell();

    cell message = begin_cell()
        .store_ref(inner_cell)
        .store_ref(inner_cell)
        .end_cell();

    slice msgSliceParser = message.begin_parse();

    while (msgSliceParser.slice_refs_empty?() != -1){ ;; -1 æ˜¯è¡¨ç¤º true ä¸ä¸ºç©ºï¼Œ 0 è¡¨ç¤º true ä¸ºç©º
        cell inner_cell = msgSliceParser~load_ref();
        ;; è¿­ä»£å¤„ç†
    }
}

() buildMsg1() {
    slice addr = "EQUQxxx";
    int amount = 1000000000; ;; 1 TON

    int op = 0;
    cell msg = begin_cell()
        .store_uint(0x18,6)
        .store_slice(addr)
        .store_coins(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)  ;;107
        .store_uint(op,32)
        .end_cell();

    send_raw_message(msg, 1 + 2); ;; 1 åˆ†å¼€æ”¯ä»˜è´¹ç”¨ï¼Œ 2 å¿½ç•¥é”™è¯¯
}

;; How to contain a body as ref to an internal message cell
;; å¦‚ä½•åœ¨ å†…éƒ¨æ¶ˆæ¯ ä¸­é™„å¸¦ä¸€ä¸ªæ¶ˆæ¯ä½“(msg body)
() buildMsg2() {
    slice addr = "EQUQxxx";
    int amount = 1000000000; ;; 1 TON
    int op = 0;

    cell message_body = begin_cell()
        .store_uint(op,32)
        .store_slice("ðŸš€")
        .end_cell();

    cell msg = begin_cell()
        .store_uint(0x18,6)
        .store_slice(addr)
        .store_coins(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)  ;;107
        .store_uint(1,1);; è®¾ç½®ä½ä¸º 1ï¼Œè¡¨æ˜Ž cell å°†ç»§ç»­ä¼ è¾“
        .store_ref(message_body)
        .end_cell();

    send_raw_message(msg, 1 + 2); ;; 1 åˆ†å¼€æ”¯ä»˜è´¹ç”¨ï¼Œ 2 å¿½ç•¥é”™è¯¯ .(ä»Žåˆçº¦ä½™é¢ä¸­æ”¯ä»˜ä½£é‡‘å¹¶å¿½ç•¥é”™è¯¯ã€‚)
}

(int) tlen(tuple t) asm "TLEN";
forall X -> (tuple) to_tuple(X x) asm "NOP";


() to_tuple_loop(){
    tuple t = to_tuple([1,2,3,4,5]);
    int len = t.tlen();

    int i = 0;
    while(i < len){
        int x = t.at(i);
        i = i + 1;
    }


}



;; () send_raw_message(cell msg, int mode) impure asm "SENDRAWMSG";

;;; Sends a raw message contained in msg,
;; å‘é€ä¸€ä¸ªåˆçº¦å†…éƒ¨æ¶ˆæ¯ï¼Œ
;;; which should contain a correctly serialized object Message X,
;; éœ€è¦åŒ…å«ä¸€ä¸ªåºåˆ—åŒ–çš„æ¶ˆæ¯å¯¹è±¡ï¼Œå…·ä½“æ¥è¯´å°±æ˜¯å¤„ç†æˆ cell
;;; with the only exception that the source address is allowed to have dummy value addr_none
;; å”¯ä¸€çš„ä¾‹å¤–æ˜¯ï¼Œæ¥æºåœ°å€å¯ä»¥ä½¿ç”¨å‡çš„å ä½ç¬¦å˜é‡ addr_none
;;; (to be automatically replaced with the current smart contract address),
;; (è¿™ä¸ªå ä½ç¬¦å°†è¢«è‡ªåŠ¨æ›¿æ¢ä¸ºå½“å‰å‘é€æ¶ˆæ¯çš„åˆçº¦åœ°å€)
;;; and ihr_fee, fwd_fee, created_lt and created_at fields can have arbitrary values
;; å¹¶ä¸” ihr_fee, fwd_fee, created_lt å’Œ created_at è‡ªåŠ¨å¯ä»¥å¡«å†™ä»»æ„å­—æ®µ
;;; (to be rewritten with correct values during the action phase of the current transaction).
;; (å› ä¸ºåœ¨æ‰§è¡Œé˜¶æ®µè¿™å‡ ä¸ªå˜é‡ä¼šè¢«é‡å†™)

;;;;;;;;;;;;  Flags è¯´æ˜Ž  ==================================
;;; Integer parameter mode contains the flags.
;; è¿˜æœ‰ä¸€ä¸ªå‚æ•°æ˜¯æ•´æ•°ç±»åž‹çš„ flag
;;; Currently mode = 0 is used for ordinary messages;
;; mode = 0 æ˜¯ç”¨äºŽæ™®é€šæ¶ˆæ¯

;;; mode = 128 is used for messages that are to carry all the remaining balance of the current smart contract
;; mode = 128 æ˜¯åœŸåŒªæ ‡å¿—ï¼Œå°†æŠŠæœ¬åˆçº¦ä½™é¢éƒ½å¸å¹²
;;; (instead of the value originally indicated in the message);
;; (128 ä¼˜å…ˆçº§é«˜äºŽæ¶ˆæ¯ä¸­åŽŸå§‹æŒ‡å®šçš„ value)

;;; mode = 64 is used for messages that carry all the remaining value of the inbound message in addition to the value initially indicated in the new message
;; mode = 64 (äºŒè¿›åˆ¶1000000)  æ˜¯ä¸€ä¸ªç»…å£«æ¨¡å¼ï¼Œå°†å‰©ä½™ä»·å€¼å¸¦èµ°ï¼Œå½“ç„¶å¦‚æžœå‘é€æ—¶å€™ç»™â€œå°è´¹â€ï¼Œä¹Ÿä¼šä¸€å¹¶å¸¦èµ°
;;; (if bit 0 is not set, the gas fees are deducted from this amount);
;; å¦‚æžœ ç¬¬ 0 ä½æ²¡æœ‰è®¾ç½®ï¼Œgas fees å°†ä»Žè¿™ä¸ªä½™é¢ä¸­æ‰£é™¤
;;; mode' = mode + 1 means that the sender wants to pay transfer fees separately;
;; å¦‚æžœ mode' = mode + 1 ï¼ˆ 64+1 = äºŒè¿›åˆ¶1000001ï¼‰ è¡¨ç¤ºå‘é€è€…ä»˜ gas fee
;;; mode' = mode + 2 means that any errors arising while processing this message during the action phase should be ignored. Finally,
;; å¦‚æžœ mode' = mode + 2 ï¼ˆ 64+2 = äºŒè¿›åˆ¶1000010ï¼‰ è¡¨ç¤ºå¿½ç•¥ Action é˜¶æ®µçš„å¼‚å¸¸
;;; mode' = mode + 32 means that the current account must be destroyed if its resulting balance is zero.
;; å¦‚æžœ mode' = mode + 32 ï¼ˆ 64+32 = äºŒè¿›åˆ¶1100000ï¼‰ è¡¨ç¤ºå¿½ç•¥ Action é˜¶æ®µçš„å¼‚å¸¸
;;; This flag is usually employed together with +128.
;; è¿™ä¸ª flag é€šå¸¸å’Œ 128(10000000) ä¸€èµ·ä½¿ç”¨

